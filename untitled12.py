# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hf9KX0W2xTKgpOUWIWT_7XXHT7RtZTPv
"""

class person:
    def __init__(self, name, id, gender):
        self.name = name
        self.id = id
        self.gender = gender

# Inheriting all the attributes from the parent class to the child class
class Student(person):

    def __init__(self, marks, name, id, gender):
        super().__init__(name, id, gender)

        self.marks = marks
class Teacher(person):
    def __init__(self, name, id, gender, salary, department):
        super().__init__(name, id, gender)
        self.salary = salary
        self.department = department

student = Student(40, "krish", 10, "male")
teacher = Teacher("krish", 102, "male", 20000, "cse")
teacher.name

class Animal:
    def __init__(self, name):
        self.name = name

    def sound(self):
        print(f"name : {self.name}")

class Dog(Animal):
    def __init__(self):
        super().__init__("Dog")

    def sound(self):
        print(f"{self.name} barks")

class Cat(Animal):
    def __init__(self):
        super().__init__("Cat")

    def sound(self):
        print(f"{self.name} meows")

dog.sound()
cat.sound()

class Vehicle:
    def __init__(self, brand, colour):
        self.brand = brand
        self.colour = colour

class Car(Vehicle):
     def __init__(self, brand, colour, speed, price):
       super().__init__(brand, colour)
       self.speed = speed
       self.price = price

     def display(self):
        print(f"brand: {self.brand}")
        print(f"colour: {self.colour}")
        print(f"speed: {self.speed}")
        print(f"price: {self.price}")

car1 = Car("Scorpio", "Black", 100, "21LAkhs")

car1.display()

class Employee:
    def __init__(self, name, id):
        self.name = name
        self.id = id

class Manager(Employee):
     def __init__(self, name, id, department):
       super().__init__(department)
       self.department = department

     def display(self):
         print(f"name: {self.name}")
         print(f"id: {self.id}")
         print(f"department: {self.department}")

class Developer(Employee):
    def __init__self(self, namr, id, programming_language):
       super().__init__(programming_language)
       self.programming_language

    def display(self):
        print(f"name: {self.name}")
        print(f"id: {self.id}")
        print(f"programmig_language")

# Multiple inheritance

class GrandFather:
    def message(self):
          print("This message from grand father")
# Inherenting the property of the grandfather to the father
class Father(GrandFather):
    def message_from_father(self):
          print("This message from father")
# Inhereting the property from the father to child

class Child(Father):
    def message_from_child(self):
        print("This message from child")
# Creating  the child object
c = Child()
# This message show grandfather
c.message()
c.message_from_father()
c.message_from_child()

# Multiple Inheritance
class Father:
    def manner(self):
        return "Has good mannners"

class Mother:
     def bargaining(self):
        return "Has good bargaining skills!"

class Child(Mother, Father):
      def gaming(self):
        return "Has good gaming skills"

c = Child()
c.manner()

class Teacher:
     def __init__(self, subject, expirence):
        self.subject = subject
        self.expirence = expirence

class Singer:
    def __init__(self, song, genre):
        self.song = song
        self.genre = genre

class Person(Teacher, Singer):
    def __init__(self, name, age, subject, expirence, genre, song):
        Teacher.__init__(self, subject, expirence)
        Singer.__init__(self, song, genre)
        self.name = name
        self.age = age
p = Person("krish", 21, "python", 3, "classical", "soaf")
p.song

class Singer:
   def __init__(self, no_song, genre, album_released):
    self.no_song = no_song
    self.genre = genre
    self.album_released = album_released

class Teacher:
    def __init__(self, ye_exp, qualification):
        self.ye_exp = ye_exp
        self.qualification = qualification

class Person(Singer, Teacher):
    def __init__(self, name, age, gender, no_song, genre, album_released, ye_exp, qualification):
        Singer.__init__(self, no_song, genre, album_released)
        Teacher.__init__(self, ye_exp, qualification)
        self.name = name
        self.age = age
        self.gender = gender

    def display(self):
        print(f"name : {self.name}")
        print(f"age : {self.age}")
        print(f"gender : {self.gender}")
        print(f"no_song : {self.no_song}")
        print(f"genre : {self.genre}")
        print(f"album_released : {self.album_released}")
        print(f"ye_exp : {self.ye_exp}")
        print(f"qualification : {self.qualification}")



P1 = Person(name = "Krish", age = 21, gender = "Male", no_song = 50,
    genre = "pop", album_released = 2025,
    ye_exp = 2, qualification = "BCA")

P1.display()

# Make a bank mangment system
# withdraw, balance, deposit --> private attribute
# Getter and Setter

class BankAcc:
   def __init__(self, name, balance):
      self.name = name
      self.__balance = balance

   # Getter method to get the balance
   def display_bal(self):
       print(f"your balance is : {self.__balance}")

   # Setter method to deposit the balance
   def deposit(self, amount):
      if amount > 0:
        self.__balance += amount
        print(f"Amount deposited succesfully")
        self.display_bal()
   # Withdrawning the balance
   def withdraw(self, amount) :
      if amount < self.__balance:
         self.__balance -= amount
         print("Amount withdrawn sucessfully")
         self.display_balance()
acc = BankAcc('krish', 50000000)
acc.deposit(4500)
# acc.display_bal()

# polymorphism ---< IT is a concept in ehich mean many form
# (1). Overloading ---> NOt possible most of question
# (2). Overriding --->
class A:
  def show(self):
    print("hello from a")
class B:
  def show(self):
    print("hello from b")
class C:
  def show(self):
    print("hello from c")
class D(C):
    pass
obj = D()

D.__mro__
# method resolution order ---> in python defines the order in which methods are
# searched for and inherited in a class hierarchy
# especially crucial in scenarious involving multiple inheritence

# for obj in [A(), B(), C()]:
#     obj.show()

class Mother:
  def skills(self):
     print("manage house")
class Father:
  def skills(self):
     print("manage finance")
class c(Father, Mother):
    pass
obj1 = c()
c.__mro__

class Animal:
  def sound(Self):
    print("Animal makes a sound")
class Dog(Animal):
  def sound(self):
    print("Dog barks")
class Cow(Animal):
  def sound(self):
    print("cow meoos")
class Cat(Animal):
  def sound(self):
    print("Cat meows")

for obj in [Dog(), Cow(), Cat()]:
    obj.sound()

class Person:
     def __init__(self, name, age):
        self.name = name
        self.age = age
     def display(self):
        print(f"name: {self.name}")
        print(f"age: {self.age}")
class Employee(Person):
    def __init__(self, name, age, id):
        super().__init__(name, age)
        self.id = id
    def display(self):
        print(f"name: {self.name}")
        print(f"age: {self.age}")
        print(f"id: {self.id}")
class Manager(Employee):
    def __init__(self, name, age, id, department):
        super().__init__(name, age, id)
        self.department = department
    def display(self):
        print(f"name: {self.name}")
        print(f"age: {self.age}")
        print(f"id: {self.id}")
        print(f"department: {self.department}")

m = Manager("krish", 21, "E102", "SOFTWARE")
m.display()

class Vehicle:
    def move(self):
       print("vehicale is moving")
class Car(Vehicle):
    def move(self):
       print("Car drives in road")
class Boat(Vehicle):
    def move(self):
       print("Boat sails on water")

ve = [Vehicle(), Car(), Boat()]

for v in ve:
    v.move()

class Camera:
     def capture(self):
        print("photoshoot")
class Phone:
     def call(self):
        print("calling")

class Smartphone(Camera, Phone):
     def browse(self):
        print("browsing data")

s = Smartphone()

s.capture()
s.call()
s.browse()

class Student:
    def __init__(self, name, roll_no):
        self.name = name
        self.roll_no = roll_no

    def display(self):
        print(f"Name: {self.name}")
        print(f"Roll No: {self.roll_no}")

class Marks(Student):
    def __init__(self, name, roll_no, m1, m2, m3):
        super().__init__(name, roll_no)
        self.m1 = m1
        self.m2 = m2
        self.m3 = m3

    def display(self):
        super().display()
        print(f"Marks: {self.m1}, {self.m2}, {self.m3}")

class Result(Marks):
    def __init__(self, name, roll_no, m1, m2, m3):
        super().__init__(name, roll_no, m1, m2, m3)
        self.total = self.m1 + self.m2 + self.m3
        self.average = self.total / 3


    def display(self):
        super().display()
        print(f"Total Marks: {self.total}")
        print(f"Average Marks: {self.average:.2f}")


r1 = Result("krish", 567, 345, 76, 67)
r1.display()

# Encapsulation ----> is a core_object orinted programming(OOP)
# concept that bundles data(variable) and the methods that operate data into
# sigle unit, like a class, and restricts direct access to the object internal
# state

class BankAcc:
   def __init__(self, acc_no, balance):
      self.acc_no = acc_no
      self.balance = balance

acc = BankAcc(9901, 100.00)
print(acc.balance)
acc.balance = 200.00
print(acc.balance)

# Encapsulation

# There are three attribute into the Encapsulation
# Acees Attribute (Public Private, Protected)

class Student:
    def __init__(self, name, marks):
        self.name = name
        # Private
        self.__marks = marks
    # Getter
    def display(self):
        return self.__marks

s1 = Student("krish", 45)
print(s1.name)
print(s1.display())
s1.display()

class Student:
    def __init__(self, name, marks):
        # Public attribute
        self.name = name
        # private
        self.__marks = marks
    # Getter
    def display(self):
        # here we're accessing the private attribute
        return self.__marks
     # setter
    def change(self, mark):
        self.__marks = mark
s1 = Student("krish", 45)
s1.change(90)
print(s1.display())

class BankAccount:
    def __init__(self, holder, balance):
        self.holder = holder
        self.__balance = balance

    def display(self):
        return self.__balance

    def change(self, amount):
        self.__balance = amount


    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount


    def withdraw(self, amount):
        # if 0 < amount <= self.__balance:
            self.__balance -= amount

acc = BankAccount("krish", 45)
acc.deposit(90)
acc.withdraw(85)
print(acc.display())

class Employee:
    def __init__(self, name, salary):
        self.__name = name
        self.__salary = salary

    def get_salary(self):
        return self.__salary

    def set_salary(self, salary):
        if salary > 0:
            self.__salary = salary


e1 = Employee("krish", 5000)
print(e1.get_salary())

class Product:
    def __init__(self, name, price, quantity):
        self.name = name
        self.__price = price
        self.__quantity = quantity

    def display(self):
        return self.__price, self.__quantity

    def change(self, price, quantity):
        if price > 0:
            self.__price = price
        if quantity > 0:
            self.__quantity = quantity

    def total(self):
        return self.__price * self.__quantity


p1 = Product("Laptop", 50000, 3)
p1.change(650, 5)
print(p1.display())
print(p1.total())

class Vehicle:
    def __init__(self, speed):
        self._speed = speed

class Car(Vehicle):
    def show_speed(self):
        return self._speed

    def change_speed(self, speed):
        self._speed = speed

c1 = Car(100)
c1.change_speed(50)
print(c1._speed)

class Temperature:
    def __init__(self, celsius):
        self.__celsius = celsius

    @property
    def fahrenheit(self):
        return (self.__celsius * 9/5) + 32

    @fahrenheit.setter
    def fahrenheit(self, value):
        self.__celsius = (value - 32) * 5/9

    def get_celsius(self):
        return self.__celsius

temp = Temperature(0)

print("Celsius:", temp.get_celsius())
print("Fahrenheit:", temp.fahrenheit)

temp.fahrenheit = 212
print("Celsius after setting 212°F:", temp.get_celsius())

class Vehicle:
    def start(self):
        print("vehicle start")
    def stop(self):
        print("vehicle stop")

class Car(Vehicle):
    def start(self):
        print("car start")
    def stop(self):
        print("car stop")

c = Car()
c.start()

# Abstraction:

from abc import ABC, abstractmethod
# Abstract base class
class Vehicle(ABC):
    @abstractmethod
    def start(self):
        pass
    def stop(self):
        pass

class Car(Vehicle):
    def start(self):
        print("The car has started and run with the petrol")
class Bus(Vehicle):
    def start(self):
        print("The bus has started and run with the diesel")

c = Bus()
c.start()

from abc import ABC, abstractmethod

class Payment(ABC):
    @abstractmethod
    def make_payment(self, amount):
        pass

    # def not_pay(self, amount):
    #     pass

class Cr_card(Payment):
    def make_payment(self, amount):
        print(f"Paid {amount} using credit card")

class upi(Payment):
      def make_payment(self, amount):
          print(f"Paid {amount} using UPI")

Pay = Cr_card()
Pay.make_payment(500)

from abc import ABC, abstractmethod

class DocumentReader(ABC):
    @abstractmethod
    def read_document(self, file_path):
        pass

class PDFReader(DocumentReader):
      def read_document(self, file_path):
          print(f"Reading PDF file : {file_path}")

class WordReader(DocumentReader):
      def read_document(self, file_path):
          print(f"Reading world file : {file_path}")

file = PDFReader()
file.read_document("in document format")

from abc import ABC, abstractmethod

class SmartDevice(ABC):
    @abstractmethod
    def turn_on(self):
        pass

    @abstractmethod
    def turn_off(self):
        pass

class SmartLight(SmartDevice):
      def turn_on(self):
          print("Light is turned on")
      def turn_off(self):
          print("Light is turned off")
class SmartFan(SmartDevice):
      def turn_on(self):
          print("Fan is turned on")

      def turn_off(self):
          print("Light is turned off")

c = SmartLight()
c.turn_on()

from abc import ABC, abstractmethod

class notification(ABC):
    @abstractmethod
    def send(self,message):
        pass
class EmailNotification(notification):
    def send(self, message):
        print(f"Sending Email: {message}")
class PushNotification(notification):
    def send(self, message):
        print(f"Sending Push Notification: {message}")

c = PushNotification()
c.send("Hello, World!")

v = EmailNotification()
v.send("Mail Check Kro")

from abc import ABC, abstractmethod

class DeliveryPartner(ABC):
    @abstractmethod
    def deliver_order(self,order_id):
        pass
class ZomatoPartner(DeliveryPartner):
    def deliver_order(self, order_id):
        print(f"Zomato is delivering order {order_id}")
class SwiggyPartner(DeliveryPartner):
    def deliver_order(self, order_id):
        print(f"Swiggy is delivering order {order_id}")

order = SwiggyPartner()
order.deliver_order(12345)

from abc import ABC, abstractmethod
import math

class Shape(ABC):
    @abstractmethod
    def calculate_area(self, calculate_area):
        pass
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def calculate_area(self):
        return math.pi * self.radius ** 2


class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def calculate_area(self):
        return self.width * self.height


class Triangle(Shape):
    def __init__(self, base, height):
        self.base = base
        self.height = height

    def calculate_area(self):
        return 0.5 * self.base * self.height

shapes = [
    Circle(5),
    Rectangle(4, 6),
    Triangle(3, 7)
]

for shape in shapes:
    print(f"Area: {shape.calculate_area()}")

from abc import ABC, abstractmethod
class MusicPlayer(ABC):

    @abstractmethod
    def play(self):
        pass

    @abstractmethod
    def pause(self):
        pass

    @abstractmethod
    def stop(self):
        pass
class SpotifyPlayer(MusicPlayer):
    def play(self):
        print("Spotify is playing music.")

    def pause(self):
        print("Spotify music paused.")

    def stop(self):
        print("Spotify music stopped.")


class AppleMusicPlayer(MusicPlayer):
    def play(self):
        print("Apple Music is playing music.")

    def pause(self):
        print("Apple Music paused.")

    def stop(self):
        print("Apple Music stopped.")
def use_music_player(player: MusicPlayer):
    player.play()
    player.pause()
    player.stop()

spotify = SpotifyPlayer()
apple = AppleMusicPlayer()

use_music_player(spotify)
use_music_player(apple)